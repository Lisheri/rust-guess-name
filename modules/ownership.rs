use std::rc::{Rc, Weak};
// 所有权
// rust核心功能之一, 就是所有权(ownership)
// 该 "特性" 对rust编程有着深刻的影响

/**
* 程序管理内存有多种方式:
* + 一些语言具有垃圾回收机制, 在程序运行时有规律的寻找不在使用的内存.(js, python等)
* + 在另一些语言中, 需要开发人员手动释放和分配内存(C语言)
* ! Rust选择了另外一条路: 通过所有权管理内存
*   - 编译器在编译时会根据一系列规则进行检查, 违反任何规则程序都不能通过编译. 在运行时, 所有权系统的任何功能都不会减慢系统运行
* ! 对所有权规则的掌握, 是编写Rust高效和安全代码的基础
*/

/**
 * Rust堆和栈
 * 堆和栈都是代码运行时可供使用的内存, 但是结构不同.
 * 栈中所有数据都必须占据已知且固定的大小. 在编译时大小未知或大小可能变化的数据, 需要更改为存储在堆上.
 *
 * 堆是缺乏组织的: 当向堆中增加数据时, 需要请求一定大小的空间.
 * 内存分配器(memory allocator)在堆的某处找到一块足够大的空位, 并将其标记为已使用, 并返回一个表示该位置地址的 指针(Pointer).
 * 上述过程被称为: 在堆上分配内存(allocating on the heap), 也叫做 "分配(allocating)"
 * ! 注: 将数据推入栈中并不被认为是"分配"
 *
 * 因为指向放入堆中数据的指针是已知的并且大小是固定的, 可以将该指针存储在栈上, 不过需要实际数据时, 必须访问指针.
 *
 * 入栈比堆上分配内存更快, 因为入栈时分配器无需为存储数据搜索内存空间, 位置也总是在栈顶. 相比之前, 在堆上分配内存需要更多的操作
 * 不仅是要找到一块足够的空间存放数据, 还需要做一些记录为下一次分配做准备.
 *
 * 访问堆上数据也比访问栈中数据更慢, 因为需要通过指针进行访问. 现代处理器在内存中跳转越少就越快(缓存)
 *
 * 当代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。(和C++一样)
 *
 * 跟踪哪部分代码正在使用堆上的哪些数据, 最大限度的减少堆上的重复数据数量, 清理堆上不再使用的数据确保不会耗尽空间, 这些问题正是所有权系统要处理的.
 *
 *
 */

/**
 * 所有权规则:
 * + Rust中每个值都有一个所有者
 * + 值在任一时刻有且只有一个所有者
 * + 当所有者(变量)离开作用域, 这个值将被丢弃
 */

// 变量作用域
pub fn variables_scope() {
    // 作用域是一个项（item）在程序中有效的范围
    // 假设如下变量
    let s = "hello";
    // 变量s绑定了一个字符串的值, 这个字符串值是通过硬编码进程序代码中的. 这个变量从声明的点开始直到当前`作用域`结束时都是有效的
    // 比如下面的声明方式
    {
        // s在当前块级作用域中暂时无效, 因为还没有被声明
        let s = "hello2"; // 从这里开始, s已经有效
                          // 使用s
        println!("s是这个东西: {s}");
    } // 作用域结束, s不再生效(和c++类似)
      // 有两个重要的时间点:
      // + 当 s 进入作用域 时, 它是有效的
      // + 这一直持续到它 离开作用域 为止

    // 到上面为止, 变量和作用域的关系, 和其他语言是类似的
}

// String类型 变量作用域
pub fn variables_scope_string() {
    // 前面所有的类型都过于简单, 都是存储在栈中的数据, 离开作用域则出栈
    // 如果代码的另一部分需要在不同的作用域中使用相同的值, 可以快速简单的复制来创建一个新的独立实例
    // 因此我们需要找到一个存储在堆上的数据来探索Rust如何直到该在何时清理数据.

    // 前面说过字符串字面值, 也就是被硬编码进入程序的字符串值
    // 字符串字面值很方便, 不过他们并不适合使用文本的每一种场景
    // 主要原因在于: 1. 他们都是不可变的 2. 并非所有字符串的值都能够在编写代码时就知道, 比如获取用户输入的值

    // 为此, Rust出现了第二种字符串类型: String
    // 这个类型用于管理被分配到 堆 上的数据, 能够存储在编译时未知大小的文本
    // 可以使用 from 函数基于字符串字面值来创建 String, 如下:
    let mut s = String::from("草拟吗"); // ? 这里的String是一个模块命名空间, from是其中实现的一个方法
    s.push_str(", 狗东西!"); // push_str() 在字符串后追加字面值
    println!("{}", s); // 打印结果: 草拟吗, 狗东西!
}
/**
 * 为什么String可变, 但是 &str 不行?
 * 主要区别在于对内存的处理上
 * 
 * 对于字符串字面值(&str), 在编译时就知道其内容, 所以文本被直接硬编码进最终的可执行文件中. 这使得字符串字面值快速且高效.
 * 不过这些都是因为字符串字面值是不可变的.
 * 我们并不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中, 并且它的大小还可能随着程序运行而改变
 * 
 * 对于 String 类型, 为了支持一个可变, 可增长的文本片段, 需要在堆上分配一块在编译时未知大小的内存来存放内容, 意味着:
 * + 必须在运行时向内存分配器(memory allocator)请求内存
 * + 需要一个当我们处理完 String 时将内存返回给分配器的方法
 * 
 * 第一步就是调用 `from` 方法
 * 第二步在有GC的语言中, GC检查变量是否不再使用, 进一步对其进行回收. 而对于C这类语言, 则是需要开发人员主动完成析构函数, 对变量进行回收
 * 但如果忘记回收, 会造成内存浪费, 过早回收, 又会出现无效变量, 重复回收, 会产生bug
 * 我们需要精确的为一个 `allocator` 配对一个 `free`
 * 
 * Rust的内存策略: 内存在拥有它的变量离开作用域后就被自动释放.
 * ? 比如上述的例子, 在块级作用域结束后, 内部s也就被回收了, 后续也无法继续使用
 * ? 其实在离开作用域时, rust会自动调用一个 `drop` 函数, 类似c++的析构函数, 将内部变量完全回收
 * ? 这个模式和C++的 RAII(Resource Acquisition Is Initialization) 资源获取即初始化 类似
 */

// 上述资源离开作用域自动 drop 的模式虽然看起来很好, 但是在更复杂的场景下代码的行为会变得难以预测, 比如有多个变量使用在堆上分配内存时


pub fn variables_move_and_clone_on_heap() {
    // + 变量与数据交互的方式(一): 移动
    // 在 Rust 中, 多个变量可以采取不同的方式与同一数据进行交互

    // 栈存储, 没啥好说的, x和y都是栈上独立空间, 只不过他们的值都是5
    let x = 5;
    let y = x;
    
    // 堆存储
    // 看起来和上述行为非常类似, 第二行生成s1的拷贝并绑定到s2上
    // 不过, 事实并不完全是这样的
    // String由三个部分组成: 栈上指针s1(ptr), 长度(len), 容量(capacity), 堆上存放字符串的内容
    // 长度: 表示 String 的内容当前使用了多少字节的内存
    // 容量: 表示 String 从分配器总共获取了多少字节的内存
    // ! 注意: 长度和容量是不同的, 比如Vector, 可能申请了30的字节, 但实际只使用了15的字节
    let s1 = String::from("hello");
    // 在这里将s1赋值给s2时, String 的数据被复制了, 意味着我们从栈上拷贝了它的指针, 长度和容量
    // 我们并没有复制指针指向的堆上数据(类似js的对象直接拷贝)
    // rust并不会拷贝堆上数据, 否则在堆上数据较大时, 会出现极大的内存隐患(这一点, c, js等均如此)
    let s2 = s1;
    // 这里, s1和s2两个指针都指向同一个地址
    // 前面说过当变量离开作用域时, rust会自动调用drop函数, 来清理变量的内存.
    // 此时两个指针指向了同一个地址, 当s1和s2离开作用域时, 他们都会尝试释放相同的内存.
    // 因此, 这里会产生 `二次释放`的错误, 这也是之前提过的内存安全性bug之一
    // 两次释放相同内存会导致内存污染, 可能会导致潜在的安全漏洞
    
    // 解决方案: Rust解决此问题很粗暴
    // 为了保证内存安全, 当执行 let s2 = s1; 以后, Rust会认为s1不在有效, 因此Rust不需要在 s1 离开作用域后清理任何东西
    // 所以在这个位置如果使用s1, 会直接panic, 提示无效变量

    // 其实s2 = s1, 类似浅拷贝, 只不过rust还让 s1 无效了
    // 这个做法, 其实叫做 `移动(move)`, 而不是浅拷贝
    // 其实是s1指针, 整体移动到了s2
    // 这样目的就达成了, 因为只有 s2 是有效的
    // ! 这里还有一个隐藏设计, Rust永远不会自动创建数据的 "深拷贝", 因此, 任何自动的复制可以被认为对运行时性能影响较小
    
    // + 变量与数据交互的方式(二): 克隆
    // 如果不想执行移动, 也可以使用 clone, 直接进行克隆, 但是克隆类似深拷贝, 相当消耗资源
    let s3 = s2.clone();
}

// Copy trait(拷贝)
pub fn variables_copy_on_heap() {
    // 对于只在栈上的数据, rust会进行拷贝.
    // 像整型这样的在编译时已知大小的类型被整个存储在栈上, 所以拷贝其实际的值是快速的.
    // 意味着没有理由在创建y后使x无效
    // 和其他语言一样, 栈上的数据, 是没有深浅拷贝区别的, 这里调用 clone 和直接拷贝, 并不会产生任何区别, 因此不必理会
    let x = 5;
    let y = x;

    // Rust有一个叫做 Copy trait 的特殊注解, 可以用在类似整型这样的存储在栈上的类型上.
    // 如果一个类型实现了 Copy trait, 那么一个旧的变量在将其赋值给其他变量后仍然可以使用
    // ! 注: Rust并不允许自身或其任何部分实现了 `Drop` trait 的类型使用 `Copy` trait .
    // ! 如果强行对其值离开作用域时需要特殊处理的类型使用 Copy 注解, 将会编译错误
    // ! Copy 与 Drop 不能共存
    // ! copy 的行为是隐式行为，开发者不能重载 Copy 行为，它永远都是一个简单的位复制。

    // 任何一组简单标量值的组合都可以实现 Copy, 任何不需要分配内存或某种形式资源的类型都也可以实现 Copy, 如下:
    // + 所有整数类型
    // + bool类型
    // + 所有浮点数类型
    // + 字符类型
    // + 元组(不过需要内部所包含的所有类型都实现了Copy) 
    // + struct 也可以实现Copy trait


}

// 函数所有权与Copy trait
pub fn ownership_in_func() {
    // 变量所有权进入函数会发生移动或者复制, 和直接赋值一样, 对实现了 Copy trait的变量会发生复制
    // 存储在堆地址上的变量则是所有权移动
    // * 理解 Copy trait
    // s在栈上, 是一个指针, hello在堆上, 是对应的值
    let s = String::from("hello");
    println!("addr of data 'hello' = {:p} on heap", s.as_ptr()); // 指向堆中存储值 hello 的地址
    println!("addr of 's' = {:p} on stack", &s); // 栈上的指针s的地址
    // s移动到函数func1中
    takes_ownership(s);
    // 此时s已经失效
    println!("------------------------------------------------------------------------------
        ----------");
    let x = 10;
    println!("x={x}");
    println!("addr of x = {:p}", &x);
    makes_copy(x);
    // x 默认实现了 Copy trait, 后续可以继续使用, 不会发生所有权的转移
    // 本质上 Copy trait 是重新分配了一块内存, 然后将数据直接 copy 进了那块栈内存中
    println!("after func2 x={x}");
    // 可以看到, 函数func2中的地址, 和外部x的地址是不同的
    // 说明x入参后, 调用了 copy trait中的实现, 开辟了新的地址, 传入函数内部
    // 在函数内部, drop掉的也是新的地址, 而不会影响外部x
    println!("after func2 addr of x = {:p}", &x);
} // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移动到函数 takes_ownership 中

fn takes_ownership(some_string: String) {
    println!("in func1, some_thing={some_string}");
    println!("in func1, addr of some_string={:p} on stack", &some_string);
    // 堆上对应同一个地址, 但是栈上不是, 这里发生了所有权移动, 栈上开辟了新的空间
    println!("in func1, addr of some_string={:p} on heap", some_string.as_ptr());
} // some_string 移出作用域并调用 drop方法

fn makes_copy(some_integer: i32) {
    println!("in func2, some_integer={some_integer}");
    println!("in func2, addr of some_integer={:p}", &some_integer);
} // some_integer 移出作用域, 出栈

// 返回值与作用域
pub fn scope_return_val() {
    let s1 = gives_ownership(); // gives_ownership 将返回值的所有权move给s1

    let s2 = String::from("hello"); // s2进入作用域
    println!("s2堆地址: {:p}", s2.as_ptr());
    println!("s2栈地址: {:p}", &s2);

    let s3 = takes_and_gives_back(s2); // s2 所有权被移动到了 takes_and_gives_back 中
    println!("s3堆地址: {:p}", s3.as_ptr()); // s3和s2堆地址相同
    println!("s3栈地址: {:p}", &s3); // 栈地址不同, 所有权发生移动, 指针内存空间往栈顶移动
    // 同时将返回值move到s3
} // s3被移出作用域同时被丢弃, s2移出作用域, 但s2已转移, 不会drop
// s1离开作用域同时被丢弃

fn gives_ownership() -> String {
    let some_string = String::from("yours"); // some_string 进入作用域
    some_string // 返回 some_string, 同时所有权被移动给调用它的函数
}

/**
 * 变量的所有权总是遵循相同的模式: 将值赋值给另一个变量时移动它。当持有堆中数据值的变量离开作用域时, 其值将通过drop被清理掉,
 * 除非数据被移动为另一个变量所有。
 * 在每个函数中都获取所有权并接着返回所有权有些多余, 应该使用更简单的方式
 * 这个方式就是 `引用(references)`
 */

// 传入字符串, 同时返回该字符串
fn takes_and_gives_back(a_string: String) -> String {
    a_string // 返回a_string, 并将所有权移动给调用的函数
}

// 所有者被释放,
// 所在值也被清除(drop)
fn print_padovan() {
    // padovan的类型是 Vec<i32>, 也就是32位整数向量
    // 在内存中, 他也是存储在一个栈帧中的(类似C++)
    // 这个栈帧中有一个容量和一个长度, 长度会随着push发生变化, 映射堆上开辟的空间大小
    // 栈帧中还包含一个指针(缓冲区地址), 指向了堆中的真实地址(缓冲区)
    // 向量的缓冲区分配在堆上, 存储的元素是32位的数值。
    // 而 padovan指针、容量和长度直接保存在 print_padovan 函数的栈帧中
    let mut padovan = vec![1, 1, 1];
    for i in 3..10 {
        let next = &padovan[&i - 3] + &padovan[&i - 2];
        padovan.push(next);
    }
    println!("p(1..10) = {:?}", padovan);
    // 释放 pavodan
    // 走到最后, 变量padovan 在函数底部超出作用域时, 程序会清除这个指针, 而这个指针指向了一个缓冲区地址
    // 那么这个缓冲区也会被清除
}

// 与变量拥有自己的值一样, tuple, struct, 以及vec均拥有自己的元素(堆上)

struct Person { name: String, birth: i32 }
impl Person {
    fn new(name: String, birth: i32) -> Self {
        Self { name, birth }
    }
}

fn compose() {
    let mut composers = Vec::new();
    composers.push(Person::new("Palestrina".to_string(), 1525));
    composers.push(Person::new("Dowland".to_string(), 1563));
    composers.push(Person::new("Lully".to_string(), 1632));

    // 最终 composers 形成了一棵较为复杂的所有权树
    // 在 compose 的栈帧中, 存储了一个 compose 栈帧
    // compose有容量和长度, 同时有一个指针, 指向了堆中的缓冲区地址
    // 在堆中的缓冲区上, 存储了三段 Person 实例, 分别拥有一个容量, 长度和缓冲区指针
    // 每一块的指针指向的都是自己的实例存储在堆上的地址, 在这个地址上存储了一个字符串值和一个32位有符号整数
    // 其实本质上他们的所有权是比较清晰的, 每一个值都都只有一个所有者, 因此何时清除他们非常的明确。
    // 因此可以通过 "树" 来描述所有权
    // 你的所有者是你"爹", 你所拥有的值都是你的"儿子", 每棵树的根节点都是一个变量。
    // 当控制流超出这个变量所在的作用域(栈帧)时, 整个所有权树都被清除
    // 这棵树严格遵循Rust中的单一所有权规则, 禁止任何形式的结构再链接
    // Rust程序中每一个值都是某棵树的成员, 都可以追溯到某个根变量
    // Rust清除某个值不会像在C/C++中使用 free 和 delete, 而是通过将其从所有权树中删除实现的

    // 看起来上述规则会让Rust不如其他语言那么强大, 但也就是因为Rust在这方面不够强
    // 他不允许开发者构建任意形式的对象图谱, 才能对程序进行更强大的分析
    // 他的安全性就是基于这种 "代码中实体关系的可追踪性"
    // 即便是有这样的限制, 在实际开发中也不会影响解决问题的灵活性, 以及找到足够完美的解决方案
    for composer in &composers {
        println!("{}, born {}", composer.name, composer.birth);
    }

    // 不过, 上面所说的所有权规则过于严苛, 因此Rust从几个方面进行了扩展
    // 1. 可以把值从一个所有者转移到另一个所有者, 从而方便构建、重塑和销毁关系树
    // 2. 标准库提供了基于引用计数的指针类型Rc和Arc, 使用它们可以在满足某些限制条件的前提下将值指定给多个所有者
    // 3. 对一个值, 可以 "借用其引用"。 引用格式生命期有限的非所有权指针(只读)

}

// 移动
fn move_func() {
    // 对多数类型而言, 给变量赋值, 给函数传值或从函数返回值这样的操作不会复制值, 而是 移动(move)值, 也就是所谓的 "转移"
    // 所谓move, 就是原来的所有者让渡这个值的 所有权 给目标所有者, 并变成初始化状态, 然后由目标所有者控制这个值的生命周期
    // Rust 程序会以每次一个值, 每次转移一个的形式构造和拆解复杂的结构
    // ! Rust确实改变了如此基础性操作的含义, 因为纵观多种目前主流语言, "赋值"操作 在其中的风格已经明显不同了
    // ? 同样使用Vec, python采用引用计数, 直接将一个vec赋值给一个新值的时候是直接拷贝指针, 并记录新的引用计数
    // ? 但是C++这样的赋值, 采取的是深拷贝的模式, 直接clone了一个新的值, 存储在堆中, 尽管消耗更大, 但是所有权清晰, 释放该值的时刻更简单。
    // ? 当然, c++程序员往往并不认可原生克隆的模式

    // ? rust模式
    // let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
    // let u = s;
    // let t = s;
    // Rust会把字符串放到堆内存中, 但是变量 s会存储在栈帧上, 有长度和容量,以及一个指向堆内存的指针(与C++一样)
    // 根据所有权规则, 任意时刻只有一个所有者, 因此, 当发生 let u = s; 时, s的所有权已经转移给了u, 同时s变量变为未初始化状态
    // 因此在u初始化完成后, 原有栈帧从s移动到u上, 指针指向地址不变, 堆内存不变
    // 这样就避开了深拷贝带来的消耗, 同时也不用去维护引用计数, 只是发生了一个简单的"移动", 编译器会认为s尚未初始化
    // 但是继续执行 let t = s; 此时会发生panic, 因为s已经被移动过了, rust编译器会抛错, ownership_double_move
    // 如果想要和C++一样的模式, 并且不发生所有权移动, 此时需要使用如下方式:
    let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
    let u = s.clone();
    let t = s.clone();

    // ! 发生转移的只是存储在栈帧中的 "特征值(value proper)" 也就只包含了3个字, 指针, 长度, 容量。而指针指向的堆内存上的内容, 从未发生变化, 变量所有权是由特征值来决定的
}

struct Person1 { name: Option<String>, birth: i32 }

fn move_vector() {
    let mut v = Vec::new();
    for i in 101..106 {
        v.push(i.to_string());
    }
    // 1. 从末尾取值
    let fifth = v.pop().unwrap();
    assert_eq!(fifth, "105");

    // 2. 从向量中间取值, 同时使用最后一个值填充
    let second = v.swap_remove(1);
    assert_eq!(second, "102");

    // 3. 用其他值换出对应的值
    let third = std::mem::replace(&mut v[2], "substitute".to_string());
    assert_eq!(third, "103");

    assert_eq!(v, vec!["101", "104", "substitute"]);

    // 上述方法均能保证向量是被填满的状态, 然后从向量中换出对应的值

    let mut composers = Vec::new();
    composers.push(Person1 { name: Some("Palestrina".to_string()), birth: 25 });

    // 不能这样做 let first_name = composers[0].name
    // 但是可以使用如下方式
    // let first_name = std::mem::replace(&mut composers[0].name, None);
    // assert_eq!(first_name, Some("Palestrina".to_string()));
    // assert_eq!(composers[0].name, None);

    // 其实上面那个 replace 的方式, 就是所谓的 take 方法, 这里的调用结果和前面replace是一样的
    // 而且使用 take处理 Option 枚举是一个非常常见的方式
    let first_name = composers[0].name.take();
    assert_eq!(first_name, Some("Palestrina".to_string()));
    assert_eq!(composers[0].name, None);
}

fn copy_ownership() {
    // 目前上面所有的例子所涉及的值的类型包含 vector, string, 和其他可能占用较多内存且复制开销较大的类型
    // move 让这些类型的所有者保持清晰, 赋值代价也小。但是对于整数或者字符这些比较简单的类型, 这种小心翼翼的处理就没有必要了。
    // 比如下面的String 赋值 与 i32 赋值在内存中的差异
    let str1 = "somnambulance".to_string();
    let str2 = str1; // 发生move

    // 与字符串不同, 字符串包含在堆内存中的字符串本体, 因此 str1赋值给str2时, 所有权就发生了移动
    // 但是 i32 只是内存中的一种位模式, 它并不包含任何堆中的资源, 除了所包含的字节以外, 什么都没有。
    // 因此在 num1 向 num2 转移时, 会把num1完整的复制一份
    let num1: i32 = 36;
    let num2 = num1;
    println!("num1: {}", num1);
    println!("num2: {}", num2);

    // 将 num1 视为未初始化确实很重要, 但其实继续使用 num1 也并没有什么坏处(开销小)。
    // 对数值类型来说, move 的好处不仅无法提现, 反而会导致不便
    // 大多数类型确实会发生move, 但也有例外, 也就是被 Rust 选定为 Copy 类型的值
    // Copy类型的值在赋值的时候会直接copy, 而不是转移所有权。
    // 赋值的原变量仍然是初始化且可用的, 值也跟原来一样
    // 将copy类型的值转移给函数和构造函数也是一样的

    // - 标准类型的Copy类型包括: 所有机器整数和浮点数类型, char和bool类型, 以及其他几种类型。
    // - Copy类型的元组或固定大小的数组本身也是 Copy类型
    // ! 注: 只有简单的 "位到位复制" 才是 Copy 类型

    // ! 有一个经验规则：任何在值被drop后需要特殊处理的类型都不能是 Copy 类型。
    // 比如 Vec 需要释放其内部元素, File需要关闭其文件句柄, 而 MutexGuard 需要解锁其互斥量。
    // 这些类型如果进行位到位复制, 会导致编译器分不清哪个值应该对原始的资源负责
}

// 默认情况下, 自定义的类型是不带Copy的, 但有时候自定义类型只是带点装饰的 值类型, 如果没有Copy会在实际开发过程中及其不便, 因此需要手动实现一个Copy

// 一个最简单的实现方式如下, 就是使用 derive宏
#[derive(Copy, Clone)]
struct Label {
  age: i32,
}
// 但是对于不是所有字段都是Copy类型的结构体, 就算使用#[derive(Copy)]也不会起作用, 比如如下结构体
// #[derive(Copy)] // 由于name是String类型， String不能实现Copy, 因此也不能为结构体 StringLabel实现Copy
// struct StringLabel {
//   name: String,
// }
fn custom_copy() {
  // 一个类型是不是Copy对于什么样的代码可以使用它有很大影响。
  // Copy类型更加灵活， 因为赋值以及相关操作不会导致变量变成未初始化状态(所有权移动了, 但是允许在作用域内继续使用)
  // 但是对于类型实现者来说, Copy类型非常受限制, 因为它无法访问堆内存
  // 因此把某个类型实现为Copy, 对于实现者来说就意味着庄严的承诺: 若日后有必要将其改为非Copy类型, 那用到它的代码很多可能需要重写
  // 在Rust中, 所有的转移都是字节对字节的浅复制, 会导致源变量变成未初始化状态。复制也一样， 只不过原变量不会变成未初始化, 但其实所有权已经发生转移了
  // C++类能够提供Rust类型无法提供的方便接口， 看起来普普通通的代码就可以隐式调整引用计数, 将开销大的复制操作延后， 或者使用其他复杂的实现技巧
  
  // 但是对于一门语言来说， C++这样的灵活性会导致赋值、传参和函数返回值变得不好预测。
  // 比如在C++中 将一个 vector<string> s 赋值给另一个变量, 会发生深拷贝, 占用任意内存空间和CPU时间。

  // 而Rust的一个原则就是, 开销应该对程序员显而易见, 基本的操作必须保持简单
  // 潜在开销大的操作应该明确, 比如在前面的例子中调用clone会对向量及其包含的字符串执行深拷贝
}


fn shared_ownership() {
  // 共享所有权
  // 尽管典型的Rust代码中大多数值拥有唯一所有者，但在某些情况下很难找到每个值只有一个所有者时所需的生命周期
  // 我们可能希望有一个值在所有操作完成时再被清理
  // 对此Rust提供了基于引用计数的两个指针RC和ARC
  // ARC是原子引用计数, 可以在线程间共享, RC则是使用更快的非线程安全的代码更新其引用
  // 如果不需要再线程间共享, 则使用RC足以
  
  // rust引用计数
  let s: Rc<String> = Rc::new(String::from("shirataki"));
  let t: Rc<String> = s.clone(); // Rc<T>调用 clone 不会深拷贝 T, 而是在栈帧上创建一个新的指针指向同一个堆地址， 同时新增引用计数(JS的引用类型)
  let u: Rc<String> = s.clone();
  // Rc<T>指向的堆地址的值不能直接修改, 比如s.push_str("noodles");
  // ! 因为Rust线程安全有一个重大的前提就是不能存在 "既可以共享又可以修改的值"
  // 这里Rust会假设Rc<T>引用的值通常是共享的, 因此不允许修改
  // ? 由于Rust提供了"内部修改能力", 可以在一定程度内修改一部分内容， 在同时使用Rc<T>和这种技术时, 就可能产生循环引用, 进而导致Rc<T>永远不会被释放, 导致内存泄漏
  // ? 可以使用 "弱引用" 解决该问题（std::rc::Weak）, 也叫弱指针, 其实就是在内层创建引用时, Rc<T>不会感知到被引用, 因此他的计数不会+1, 就不会产生上面的循环无法释放的情况了
}

// RefCell 
// 内部可变性（Interior mutability）是 Rust 中的一个设计模式，
// 允许开发者即使在有不可变引用时也可以改变数据，这通常是借用规则所不允许的。
// 因此为了修改这些数据, 需要手动声明 unsafe, 并且手动替代编译器检查
// 在确保运行时能够遵循借用规则的前提下, 可以选择使用运用内部可变性模式的类型
fn inner_mut() {

}
/**
 * 还是老生常谈的这几个所有权规则:
 * 1. Rust中每个值都有一个所有者
 * 2. 值在任一时刻有且只有一个所有者
 * 3. 当所有者(变量)离开作用域, 这个值将被丢弃
 */
pub fn main_ownership() {
    // print_padovan();
    // compose();
    // move_func()
    // move_vector();
    copy_ownership();
}
